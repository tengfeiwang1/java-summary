# 第一章
## 1.数据结构包括：数组，链表，栈，二叉树，哈希表等等
表1.1 数据机构的特性
| 数据结构 | 优点 | 缺点 |
| ------ | ------ | ------ |
| 数组 | 插入快，如果知道下标，可以非常快的存取 | 查找慢，删除慢，大小固定 | 
| 有序数组 | 比无序的数组查找快 | 删除和插入慢，大小固定 |
| 栈 | 提供后进先出(LIFO)方式的存取 | 存取其他项很慢 | 
| 队列 | 提供先进先出(FIFO)方式的存取 | 存取其他项很慢 | 
| 链表 | 插入快，删除快 | 查找慢 |
| 二叉树 | 查找，插入，删除都快（如果树保持平衡） | 删除算法复杂 |
| 红-黑树 | 查找，插入，删除都快。树总是平衡的 | 算法复杂 |
| 2-3-4树 | 查找，插入，删除都快。树总是平衡的。类似的树对磁盘存储有用 | 算法复制 |
| 哈希表 | 如果关键字已知则存取极快。插入快 | 删除慢，如果不知道关键字则存取很慢，对存储空间使用不充分 |
| 堆 | 查找，删除快，对最大数据项的存取很快 | 对其他数据项存取慢 |
| 图 | 对现实世界建模 | 有些算法慢且复制 |
数据结构处理数组之外都可以被认为时抽象数据结构（ADT）

# 第二章 数组
* 表2.5 用大O表示法表示运行时间

| 算法 | 大O表示法表示的时间 |
| ------ | ------ | ------ |
| 线程查找 | O(N) |
| 二分查找 | O(logN) |
| 无序数组的插入 | O(1) |
| 有序数组的插入 | O(N) |
| 无序数组的删除 | O(N) |
| 有序数组的删除 | O(N) |

小结：
- 无序数组可以提供快速的插入，但查找和删除较慢
- 有序数组可以使用二分查找，查找较快

# 第三章 简单排序
算法的稳定性：
如果具有相同关键字的数据项，经过排序它们的顺序保持不变，这样的排序就是稳定的。

P.52
## 冒泡排序：效率最低，一般不考虑使用
 默认最大的值移动到最右边，最右边的就是有序的
 整体时间复杂度：O(N^2)
```java
public void bubbleSort() {
            int out, in;
            for (out = nElems - 1; out > 0; out--) {//outer loop(backward)
                for (in = 0; in < out; in++) {//inner loop(forward)
                    if (array[in] > array[in + 1]) {//out of order?
                        swap(in, in + 1);//swap them
                    }
                }
            }
        }
```

## 选择排序:数据量小，交换数据耗时大于比较数据耗时，可以考虑
默认最小的值移动到最左边，默认左边的是有序的
整体时间复杂度：O(N^2)
相比较冒泡排序，选择排序交换次数为n（冒泡排序交换次数：n^2）
```java public void selectionSort() {
            int out, in, min;
            for (out = 0; out < nElems - 1; out++) {//outer loop
                min = out;//minimum
                for (in = out + 1; in < nElems; in++) {//inner loop
                    if (array[in] < array[min]) {//if min greater
                        min = in;//we have a new min
                    }
                }
                swap(out, min);//swap them
            }
        }
```

## 插入排序：数据量比较小或基本上有序时考虑使用
默认比outer变量下标号小的数据项都是局部有序的
对于随机数据的插入排序，时间复杂度：O(N^2)
对于已经有序或基本有序的数据来说，时间复杂度：O(N)

 复制的次数大致等于比较的次数。然而一次复制与一次交换的时间耗费不同（复制小于交换）， 所以相对于随机数据，这个算法比冒泡排序快一倍，比选择排序略快。
```java
        public void insertSort() {
            int in, outer;
            for (outer = 1; outer < nElems; outer++) {//outer is dividing line
                int temp = array[outer];//remove marked item
                in = outer;//start shifts at outer
                while (in > 0 && array[in - 1] > temp) {//until one is smaller
                    array[in] = array[in - 1];//shift item to right
                    --in;//左移下标 go left one position
                }
                array[in] = temp;//insert marked item
            }
        }
```


# 第四章 栈和队列

## 栈
栈是一种**先进后出（FILO）**的数据结构，数组和链表都可以生成栈。
允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom）；
* 栈的效率：数据项入栈和出栈时间复杂度都为O(1)


## 队列
队列是一种先进先出（FIFO：插入数据到队尾，队头删除数据）的数据结构，数组和链表也都可以生成队列。
当数据进入到队列中时加入到队尾（tail/rear），但是出队列的时候是从头端（head/front）取数据。
* 队列的效率：插入数据项和移除数据项时间复杂度都为O(1)

* 循环队列
  - 环绕式处理
  为了避免队列不满却不能插入新数据项的问题，可以让队头队尾指针绕回到数据开始的位置，这就是循环队列

  - 判断队列是否有环：基于链表实现，“快慢指针”的方法来判断是否有环？，参考链表部分

* 双向队列

* 优先级队列
基于数组实现的优先级队列，插入操作需要O(N)的时间，删除操作则需要O(1)的时间

# 第五章 链表

p135