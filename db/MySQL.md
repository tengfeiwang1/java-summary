- [范式](#%E8%8C%83%E5%BC%8F)
- [存储结构](#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
  - [InnoDB索引结构-聚簇索引](#innodb%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95)
  - [Myisam索引结构-非聚簇索引](#myisam%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95)
- [MySQL常用引擎](#mysql%E5%B8%B8%E7%94%A8%E5%BC%95%E6%93%8E)
  - [InnoDB](#innodb)
  - [InnoDB锁机制](#innodb%E9%94%81%E6%9C%BA%E5%88%B6)
  - [Myisam](#myisam)
- [事务](#%E4%BA%8B%E5%8A%A1)
  - [ACID属性](#acid%E5%B1%9E%E6%80%A7)
  - [MySQL 的脏读，不可重复读，幻读](#mysql-%E7%9A%84%E8%84%8F%E8%AF%BB%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%B9%BB%E8%AF%BB)
  - [事务隔离级别:Isolation Level-MySQL/InnoDB定义的4种隔离级别：](#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABisolation-level-mysqlinnodb%E5%AE%9A%E4%B9%89%E7%9A%844%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)
- [日志](#%E6%97%A5%E5%BF%97)
  - [重做日志（redo log）](#%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97redo-log)
  - [回滚日志（undo log）](#%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97undo-log)
  - [二进制日志（bin log）](#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97bin-log)
- [死锁](#%E6%AD%BB%E9%94%81)

# 范式
1. 第一范式:确保**每列**的原子性.
2. 第二范式:在第一范式的基础上更进一层，确保表中的每列都和主键相关.
3. 第三范式:在第二范式的基础上更进一层,目标是确保每列都和主键列直接相关,而不是间接相关


# 存储结构
InnoDB和Myisam都是用B+Tree来存储数据的。

# 索引
## InnoDB索引结构-聚簇索引
InnoDB 是以 ID 为索引的数据存储。
采用 InnoDB 引擎的数据存储文件有两个，一个定义文件(frm)，一个是索引和数据文件(idb)。
InnoDB 通过 B+Tree 结构对 ID 建索引，然后在**叶子节点中存储记录**。

- B+Tree树
  - 与B Tree相比，B+Tree有以下不同点
    1. 每个节点的指针上限为2d
    2. 内节点只存key
    3. 叶节点不存指针,叶节点指向被索引的数据而不是其他叶节点,在innodb中,指向的是主键,myshaym中指向的是数据的物理地址
    4. 顺序访问指针的B+Tree：在经典B+Tree的基础上进行了优化，增加了顺序访问指针，如下图所示：
![B+Tree](../java/pic/B+Tree示例.png)
    在B+Tree的每个叶节点增加一个指向相邻叶节点指针，形成带有顺序访问指针的B+Tree
    此优化的目的是提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了区间查询效率
    
    InnoDB的所有辅助索引都引用主键作为data域。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。（知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅索引都引用主索引，过长的主索引会令辅索引变得过大）

## Myisam索引结构-非聚簇索引
Myisam 引擎也是采用的 B+Tree 结构来作为索引结构。
由于 Myisam 中的索引和数据分别存放在不同的文件，所以在索引树中的叶子节点中存的数据是该索引对应的数据记录的地址，由于*数据与索引不在一起*，所以 Myisam 是非聚簇索引。

## 索引使用策略及优化
最左前缀索引

- 什么是覆盖索引
创建一个索引，该索引包含查询中用到的所有字段，称为“覆盖索引”。
（一个索引包含了满足查询结果的数据就叫做覆盖索引。）

- Btree索引的使用限制
![Btree索引的使用限制](../java/pic/Btree索引的使用限制.png)

- 什么情况下设置了索引但无法使用
  1.以“%”开头的LIKE语句，模糊匹配
  2.OR语句前后没有同时使用索引
  3.数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）


[MySQL索引及其实现原理1](../java/pic/MySQL索引及其实现原理1.png)
[MySQL索引及其实现原理2](../java/pic/MySQL索引及其实现原理2.png)


# MySQL常用引擎
## InnoDB
   InnoDB的存储文件有两个，后缀分别是.frm和.idb，其中.frm是表的定义文件，而.idb是索引和数据文件。
   InnoDB中存在**表锁和行锁**，不过行锁是在命中索引的情况下才会起作用。
   InnoDB**支持事务**，且支持四种隔离级别（读未提交，读已提交，可重复读，串行化），默认的为可重复读；而在Oracle数据库中，只支持串行化和读已提交这两种级别，其中默认为读已提交级别。
## InnoDB锁机制
>> InnoDB支持行锁（锁定字段含有索引的情况下，否则走表锁），但锁定方式并非简单的锁定指定行上的索引，而是分为3种锁定算法：
>>1) 记录锁(Record Locks)：锁定指定行的索引项
>>2) 间隙锁(Gap Locks)：锁定某一个范围内的索引，但不包括记录本身. GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。
>>3) Next-Key Locks：锁定一个范围内的索引，并且锁定记录本身. **在RR隔离级别下加行锁都是采用该方法**，主要目的是解决幻读的问题。(Next-Key Locks = Record Locks + Gap Locks)

>> InnoDB在默认配置下（隔离级别RR：可重复读；innodb_locks_unsafe_for_binlog=OFF：采用gap locking），对于索引的查询采用 Next-key locks。这样做避免了幻读现象的产生。

### MySQL 的脏读，不可重复读，幻读
* 脏读: 一个事务内修改了数据但是还没有提交，这个时候另外一个事务可以读取得到这个未提交的数据，这个样子就被称之为脏读。
* 不可重复读: 一个线程的事务读取到了另外一个线程中提交的update的数据。
* 幻读: 一个线程中的事务读取到了另外一个事务insert的数据。


### **锁触发特别的**
>>* 1. 当锁定的索引项含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。
>>* 2. 当唯一索引是由多个列组成，而query仅查询多个列中的其中一个，则依然使用 Next-key lock。
>>* 3. 通过主键或者唯一索引来锁定不存在的值，则依然使用 Next-key lock。。

**Next-Key Locks当使用主键索引进行当前读的时候，会降级为Record lock(记录锁)**

 ### RR级别下的并发控制
 1. MVCC: (Multi-Version Concurrency Control) 多版本并发控制
   MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突.

    在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，**不用加锁**。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。

tips: 需要注意的是，MVCC只在RC和RR两个隔离级别下工作，其他两个隔离级别都和MVCC不兼容。

* 快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)

    select * from table where ?;

* 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。

    **select * from table where ? lock in share mode;**

    select * from table where ? for update;

    insert into table values (…);

    update table set ? where ?;

    delete from table where ?;

所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。
　

 2. LBCC：(Lock-Based Concurrency Control) 基于锁的并发控制
  效率较低

## Myisam
   Myisam的存储文件有三个，后缀分别是.frm, .MYD, .MYI，其中.frm是表的定义文件，.MYD是数据文件，.MYI是索引文件。
   Myisam**只支持表锁**，且**不支持事务**。Myisam由于有单独的索引文件，在读取数据方面的性能很高。


# 事务
事务是一条或多条数据库操作语句的组合，具备ACID，4个特点。

## ACID属性
* 原子性（Atomicity）：一个事务被视为一个不可分割的最小单元，事务里面的操作，要么全都执行，要么全部失败回滚。
* 一致性（Consistent）：一个事务的执行不应该破坏数据库的完整性约束；在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
* 隔离性（Isolation）：事务之间的行为不应该互相影响；数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的"独立"环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
* 持久性（Durable）：事务提交之后，需要将提交的事务持久化到磁盘。即使系统崩溃，提交的数据也不应该丢失。

## 事务隔离级别:Isolation Level-MySQL/InnoDB定义的4种隔离级别：
* Read Uncommited:可以读取未提交记录。会出现脏读。此隔离级别，不会使用，忽略。
* Read Committed (RC) :保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据。
    
    快照读忽略，本文不考虑。

    针对**当前读**，RC隔离级别保证对读取到的记录加锁 (记录锁)，但是不会加间隙锁，存在幻读现象。
* Repeatable Read (RR)：(MySQL默认)保证一个事务相同条件下前后两次获取的数据是一致的。*标准的RR只能保证在同一个事务中多次读取同样记录的结果是一致的，而无法解决幻读的问题*。InnoDB的幻读解决需要依靠MVCC的实现机制做到的。
    
    快照读忽略，本文不考虑。

    针对**当前读**，RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，不存在幻读现象。
* Serializable:事务被处理为顺序执行。

    从MVCC并发控制退化为基于锁的并发控制(LBCC)。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。可以保证不同事务之间的互斥，只允许并发的读，并发写是被禁止的。

    Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。

# 日志
https://www.linuxidc.com/Linux/2018-01/150614.htm

* MySQL中有六种日志文件，分别是：事务日志(重做日志（redo log）、回滚日志（undo log）)、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。

## 重做日志（redo log）
## 回滚日志（undo log）
## 二进制日志（bin log）


#优化
https://www.cnblogs.com/liujiacai/p/7605612.html
1. InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：show status like 'innodb_row_lock%';
如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高；
2. MySQL 性能优化：组成、表的设计
- EXPLAIN:解析查询语句，定位耗时性能点；
https://blog.csdn.net/why15732625998/article/details/80388236
- 开启查询缓存。避免某些 SQL 函数直接在 SQL 语句中使用，从而导致 Mysql 缓存失效。
- 避免画蛇添足。目的是什么就取什么，例如某个逻辑是只需要判断是否存在女性，若是查到了一条即可，勿要全部都查一遍，此时要善用 limit。
- 建合适的索引。所以要建在合适的地方，合适的对象上。经常操作 / 比较 / 判断的字段应该建索引。
- 字段大小合宜。字段的取值是有限而且是固定的，这种情况下可以用 enum，IP 字段可以用 unsigned int 来存储。
- 表的设计。垂直分割表，使得固定表与变长表分割，从而降低表的复杂度和字段的数目。
1. SQL 语句优化：避免全表扫描
建索引：一般在 where 及 order by 中涉及到的列上建索引，尽量不要对可以重复的字段建索引。
尽量避免在 where 中使用 !（<>）或 or，也不要进行 null 值判断。
尽量避免在 where 中对字段进行函数操作、表达式操作。
尽量避免使用 like- %，在此种情况下可以进行全文检索。

# 死锁
通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以及访问数据库的SQL语句，绝大部分死锁都可以避免。下面就通过实例来介绍几种避免死锁的常用方法。

1. 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。由于两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可以避免。

2. 在程序以批量方式处理数据的时候，如果事先对**数据排序**，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。

3. 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。


如果出现死锁，可以用**SHOW INNODB STATUS**命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的SQL语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。

>> SHOW INNODB STATUS使用步骤
1. CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB;
打开监视器以后，默认情况下每15秒会向日志中记录监控的内容，如果长时间打开会导致.err文件变得非常的巨大，所以用户在确认问题原因之后，要记得删除监控表以关闭监视器
2. Show innodb status\G;
3. DROP TABLE innodb_monitor;